---
tags:
  - 자료구조
  - 논리구조
  - 영역
  - Stack
  - 메모리
  - LIFO
---
# 개념

##### 자료구조
- 데이터를 쌓아놓은 형태의 논리적 구조.
- 분기점(함수, 호출, 재귀 등)에서 실행 흐름 관리를 위한 추상적 개념의 데이터 구조이다
- 접근은 항상 목록의 끝에서만 일어난다.(마지막에 추가된 데이터가 가장 먼저 제거된다.)
- LIFO(Last In First Out), FILO(First In Last Out)
- **메모리의 스택이 이 구조를 기반으로 구현되었다.**

##### 메모리영역
- 제한적인 접근
- 지역변수, 매개변수, 리턴 주소를 저장한다.
- 사용 범위 내에서 제한적으로 쓰이고 사라진다.
- 생성과 사라짐이 빈번해 일일히 초기화 안해줌 -  디폴트 초기값으로 쓰레기 값이 저장된다.
스텍을 자료구조와 메모리로 나눈것은 **동일한 메모리 영역**을 서로 다른 관점에서 설명

###### 상태 표현
| 상태  | 표현  |     |
| --- | --- | --- |
| 초기값 |     |     |
| 공백  |     |     |
| 포화  |     |     |
##### 이해안가서 구현 찾아봄
###### 스택 
```
# S는 Stack집합 의 요소 
S∈Stack; item∈Element;

# 스택 S생성
createStack(S) ::= create an empty Stack S;

# S가 비어있는지 확인
isEmpty(S) ::= if (S is empty) then return true
	else return false;

# S에 item push
push(S, item){
	 = top+1;
	if(top>sizeof(S)) then overflow;
	else
		S(top) = item;
}

# S에 item pop
pop(S){
	if(top = 0) then underflow;
	else{
	return S(top);
	top = top-1;
	}
}

# S의 top의 item 반환
peek(S) ::= if(isEmpty(S)) then return error
	else return the top item of the Stack S;
	
End Stack
```
 
 **::=** 
	 '정의된다' , '다음과 같이 정의된다.' 를 의미
	 좌항이 우항으로 정의된다.
 **' == '** 
	 좌항과 우항을 비교하여 같으면 True, 다르면 False 반환
###### 스택 C언어
```
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100  // 스택 최대 크기

typedef struct {
    int top;          // 현재 스택의 top 위치
    int items[MAX_SIZE];  // 스택 항목 저장 배열
} Stack;

// 스택 생성 및 초기화
void createStack(Stack *S) {
    S->top = -1;  // 스택이 비어 있음을 표시
}

// 스택이 비어 있는지 확인
int isEmpty(Stack *S) {
    return S->top == -1 ? 1 : 0;
}

// 스택이 가득 찼는지 확인
int isFull(Stack *S) {
    return S->top == MAX_SIZE - 1 ? 1 : 0;
}

// 스택에 항목 추가 (push)
void push(Stack *S, int item) {
    if (isFull(S)) {
        printf("Overflow: 스택이 가득 찼습니다.\n");
        return;
    }
    S->items[++(S->top)] = item;  // top 증가 후 항목 저장
}

// 스택에서 항목 제거 (pop)
int pop(Stack *S) {
    if (isEmpty(S)) {
        printf("Underflow: 스택이 비어 있습니다.\n");
        exit(1);  // 비정상 종료
    }
    return S->items[(S->top)--];  // 항목 반환 후 top 감소
}

// 스택의 top 항목 조회 (peek)
int peek(Stack *S) {
    if (isEmpty(S)) {
        printf("Error: 스택이 비어 있습니다.\n");
        exit(1);
    }
    return S->items[S->top];
}

int main() {
    Stack myStack;
    createStack(&myStack);

    push(&myStack, 10);
    push(&myStack, 20);
    printf("Top 항목: %d\n", peek(&myStack));  // 20 출력
    printf("Pop 항목: %d\n", pop(&myStack));   // 20 출력
    printf("Pop 항목: %d\n", pop(&myStack));   // 10 출력

    return 0;
}

```
# 연산자([C](C.md))
- **스택 포인터**: `top` 변수가 현재 스택의 최상단 위치를 가리킴
- **주소 계산**: `stack[top]`은 `시작 주소 + (top * 요소 크기)`로 계산
- **메모리 구조**: 연속된 메모리 공간에 데이터 저장

##### 기본기능
| 용어     | 기능          | 기타                                                                                    | 이유                                                                                                          | 요약           |
| :----- | :---------- | :------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------- | ------------ |
| push   | 삽입 연산       | 먼저 top의 위치를 증가시킨후 top의 위치에 값을 삽입  <br>**(배열 기반 스택의 경우, 주소 계산: base + (top * 요소 크기))** | top은 가르키는 **위치**. 증가시키지 않고 값을 넣으면 <br>top은 마지막에 추가된 데이터값을 가르키고 있기때문에 기존 데이터가 덮여쓰여진다.                        | 선 증가<br>후 삽입 |
| pop    | 삭제 연산       | top 위치의 데이터 반환 후 top 주소 감소<br>**(연결 리스트 기반 스택의 경우 메모리 해제 필요)**                        | 데이터 위치가 유효한지 확인이 필요하다.<br>데이터가 가르키는 위치가 바닥일경우 데이터가 없기때문에 언더플로우발생                                            | 선 확인<br>후 감소 |
| top    | 맨 위의 데이터    | 현재 스택 포인터가 가리키는 주소<br>**(포인터 연산으로 주소값 직접 관리)**                                        | **포인터 역참조**  <br>- `*top` 연산으로 값 읽기  <br>- 주소값 자체가 스택 상태 추적의 기준점  <br>- 시스템 스택과 동일한 동작 방식 모방                |              |
| bottom | 맨 아래에 있는데이터 | 스택의 시작 주소 (base)<br>**(배열 기반 스택에서 고정된 주소값 보유)**                                       | **메모리 기준점**  <br>- `base` 주소를 기준으로 오프셋 계산  <br>- 스택 오버플로 검출 시 `base-top` 거리 측정  <br>- 연결 리스트 구현 시 개념적으로만 존재 |              |

| 기능            | 설명                                         |                               |
| ------------- | ------------------------------------------ | ----------------------------- |
| `createStack` | 스택 초기화                                     | `top = -1`로 설정                |
| `isEmpty`     | top이 NULL인지 확인하여 스택이 비었는지 반환               | `top == -1`이면 1(참) 반환         |
| `isFull`      | top이 스택의 끝에 있는지 확인                         | `top == MAX_SIZE-1`이면 1(참) 반환 |
| `peek/top`    | top이 가리키는 노드의 데이터 반환(노드는 제거하지 않음)          |                               |
| size          | 노드 개수를 세어 반환(별도 변수로 관리하면 O(1), 매번 세면 O(N)) |                               |
### 연결리스트 기반 동적할당 스택(주소값을 이용한 스택구현)
#### 기본구조
	data : 저장할 값 : 실제 값이 저장된다.
	next : 다음 노드를 가리키는 포인터변수 : 다음 노드의 주소가 저장된다. (이 포인터 덕분에 각 노드가 다음 노드와 연결되어 전체가 하나의 리스트(체인)처럼 동작)
	top : 가장 최근에 추가된 노드를 가리키는 포인터
#### 원리
	새 노드를 추가(push)할 때마다 동적으로 메모리를 할당하고,  
	새 노드의 `next` 포인터에 기존 top(가장 위 노드)의 주소를 저장
	각 데이터에 다음 노드를 가르키는 포인터를 포함시켜 연결리스트르 구현.
	- push : 메모리 동적할당
		1. 새로운 노드 생성
		2. 새 노드의 `next`가 현재 `top`을 가리킴
		3. `top` 포인터를 새 노드로 이동 
	- pop : 메모리 해제
		1. `top` 노드 임시 저장
		2. `top`을 다음 노드로 이동
		3. 임시 노드 메모리 해제

| 특성        | 배열 기반 스택                                                                                             | 연결 리스트 기반 스택                                                                        |
| --------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **메모리**   | 고정 크기[4](https://blog.naver.com/errorsoft666/221601668993)[7](https://suzuworld.tistory.com/63)      | 동적 확장[3](https://shine-learn.tistory.com/47)[5](https://you88.tistory.com/29)       |
| **성능**    | 빠른 접근[7](https://suzuworld.tistory.com/63)                                                           | 삽입/삭제 오버헤드[3](https://shine-learn.tistory.com/47)                                   |
| **주소 관리** | 연속 메모리                                                                                               | 포인터 연결[5](https://you88.tistory.com/29)                                             |
| **용량 제한** | 용량 초과 시 예외[4](https://blog.naver.com/errorsoft666/221601668993)[7](https://suzuworld.tistory.com/63) | 메모리 한계까지 가능[3](https://shine-learn.tistory.com/47)[5](https://you88.tistory.com/29) |
**연결리스트 기반 스택에서 "실제 데이터에 다음 노드를 가리키는 포인터를 달아준다"는 것은,  
각 노드 구조체에 데이터 필드와 함께 다음 노드의 주소(포인터)를 저장하는 필드(링크 필드)를 포함시킨다는 의미

연결리스트 기반 동적 할당 스택은 **연속적인 주소로 이루어진 배열이 아니라, 메모리 내 산발적으로(비연속적으로) 존재하는 노드들이 포인터로 서로 연결된 구조**
## 구조적 특징

- **각 노드는 동적으로 메모리를 할당받아 생성되며**, 메모리상 어디에 위치할지(주소)는 운영체제가 결정합니다.
- **각 노드는 자신의 데이터와 다음 노드의 주소(포인터)를 저장**합니다.
- 스택의 top(혹은 head) 포인터는 가장 최근에 삽입된 노드의 주소를 저장합니다.
- push 연산 시 새 노드를 할당하고, 새 노드의 포인터 필드에 기존 top의 주소를 저장한 뒤, top을 새 노드로 갱신합니다.

## 배열 기반과의 차이

|구현 방식|메모리 배치|연결 방식|임의 접근|
|---|---|---|---|
|배열 기반 스택|연속적|인덱스로 접근|O(1)|
|연결리스트 기반 스택|비연속(산발적)|포인터(주소값)로 연결|O(n)|

## 결론

- **연결리스트 기반 스택은 "포인터 배열"이 아닙니다.**
- 각각의 노드는 메모리 내 아무 곳에나 존재할 수 있으며, **각 노드에 다음 노드의 주소(포인터)를 저장해서 서로 연결**합니다.
- 따라서, **연결리스트 기반 스택은 산발적으로 존재하는 데이터 노드들을 포인터로 잇는 구조**입니다[1](https://dev-studyingblog.tistory.com/41)[3](https://taco99.tistory.com/8)[5](https://zoosso.tistory.com/874).
- 배열처럼 연속적인 메모리 공간을 사용하는 것이 아닙니다.

**내가 이해한거 = 데이터 끝마다 원산지 표기마냥 주소 붙음**
	text = [10 | 0xA2F4] -> [20 | 0xB3C0] -> [30 | NULL]
	- 10, 20, 30은 데이터
	- 0xA2F4, 0xB3C0 등은 다음 노드의 주소(원산지 표기처럼 붙어 있음)
	- 마지막 노드는 더 이상 연결된 노드가 없으므로 주소가 NULL